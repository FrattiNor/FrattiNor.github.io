<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue.js 学习（二）]]></title>
    <url>%2F2018%2F04%2F19%2F2018_4_19_2%2F</url>
    <content type="text"><![CDATA[6Vue.js 条件语句 条件判断v-if根据表达式的值(true 或 false )来决定是否插入对应的元素。v-else可以用 v-else 指令给 v-if 添加一个 “else” 块1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt; Sorry &lt;/div&gt; &lt;div v-else&gt; Not sorry &lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: &apos;#app&apos;&#125;)&lt;/script&gt; 这里在v-if里写了js的随机数（0-1），如果大于0.5为true，显示Sorry，如果小于0.5为false，显示not sorry。v-else-ifv-else-if 在 2.1.0 新增，顾名思义，用作 v-if 的 else-if 块。可以链式的多次使用1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt; A &lt;/div&gt; &lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt; B &lt;/div&gt; &lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt; C &lt;/div&gt; &lt;div v-else&gt; Not A/B/C &lt;/div&gt;&lt;/div&gt; v-else 、v-else-if 必须跟在 v-if 或者 v-else-if之后。v-show我们也可以使用 v-show 指令来根据条件展示元素用法和单独用v-if类似 总结：v-if，v-esle和v-if-else用法和js类似 7Vue.js 循环语句 v-forv-for 指令需要以 site in sites 形式的特殊语法， sites 是源数据数组并且 site 是数组元素迭代的别名。v-for 可以绑定数据到数组来渲染一个列表：1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;site in sites&quot;&gt; &#123;&#123; site.name &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: &apos;#app&apos;, data: &#123; sites: [ &#123; name: &apos;Runoob&apos; &#125;, &#123; name: &apos;Google&apos; &#125;, &#123; name: &apos;Taobao&apos; &#125; ] &#125;&#125;)&lt;/script&gt; site可以自己命名，sites是实例的一组数组v-for 迭代对象v-for 可以通过一个对象的属性来迭代数据123&lt;li v-for=&quot;value in object&quot;&gt; &#123;&#123; value &#125;&#125;&lt;/li&gt; object为对象，value为对象的属性内容（可以自己命名）也可以提供第二个的参数为键名123&lt;li v-for=&quot;(value, key) in object&quot;&gt; &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/li&gt; 键名就是对象属性名，这里key为属性名，value为属性内容还可以提供第三个参数为索引123&lt;li v-for=&quot;(value, key, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/li&gt; 简单的说索引就1234…，给每个属性都加一个（差不多是这样吧emm…）v-for 迭代整数123&lt;li v-for=&quot;n in 10&quot;&gt; &#123;&#123; n &#125;&#125;&lt;/li&gt; 会依次显示1-10 总结：v-for应该就跟for（x in y）一个用法吧 8Vue.js 计算属性 计算属性关键词: computed。计算属性在处理一些复杂逻辑时是很有用的。1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;p&gt;原始字符串: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p&gt;计算后反转字符串: &#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;Runoob!&apos; &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;)&lt;/script&gt; 这里声明了一个计算属性 reversedMessage 。提供的函数将用作属性 vm.reversedMessage 的 getter 。vm.reversedMessage 依赖于 vm.message，在 vm.message 发生改变时，vm.reversedMessage 也会更新。我们可以使用 methods（函数） 来替代 computed（计算属性），效果上两个都是一样的，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。12345methods: &#123; reversedMessage2: function () &#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125; 可以说使用 computed 性能会更好，但是如果你不希望缓存，你可以使用 methods 属性。 computed 属性默认只有 getter ，不过在需要时你也可以提供一个 setter1234567891011121314151617181920212223242526272829&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; site &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; name: &apos;Google&apos;, url: &apos;http://www.google.com&apos; &#125;, computed: &#123; site: &#123; // getter get: function () &#123; return this.name + &apos; &apos; + this.url &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.name = names[0] this.url = names[names.length - 1] &#125; &#125; &#125;&#125;)// 调用 setter， vm.name 和 vm.url 也会被对应更新vm.site = &apos;xxxx http://www.runoob.com&apos;; 从实例运行结果看在运行 vm.site = ‘xxxx http://www.runoob.com&#39;; 时，setter 会被调用， vm.name 和 vm.url 也会被对应更新。 总结：computed（计算属性）看起来和使用起来都和methods（函数）一样，区别应该就是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。 9Vue.js 监听属性 watch我们可以通过 watch 来响应数据的变化123456789101112131415161718192021222324252627282930313233&lt;div id = &quot;computed_props&quot;&gt; 千米 : &lt;input type = &quot;text&quot; v-model = &quot;kilometers&quot;&gt; 米 : &lt;input type = &quot;text&quot; v-model = &quot;meters&quot;&gt;&lt;/div&gt;&lt;p id=&quot;info&quot;&gt;&lt;/p&gt;&lt;script type = &quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el: &apos;#computed_props&apos;, data: &#123; kilometers : 0, meters:0 &#125;, methods: &#123; &#125;, computed :&#123; &#125;, watch : &#123; kilometers:function(val) &#123; this.kilometers = val; this.meters = val * 1000; &#125;, meters : function (val) &#123; this.kilometers = val/ 1000; this.meters = val; &#125; &#125; &#125;); // $watch 是一个实例方法 vm.$watch(&apos;kilometers&apos;, function (newValue, oldValue) &#123; // 这个回调将在 vm.kilometers 改变后调用 document.getElementById (&quot;info&quot;).innerHTML = &quot;修改前值为: &quot; + oldValue + &quot;，修改后值为: &quot; + newValue;&#125;)&lt;/script&gt; watch 对象创建了两个方法 kilometers 和 meters。当我们再输入框输入数据时，watch 会实时监听数据变化并改变自身的值。 总结：watch对象创建的函数名对应data里的属性名，改属性发生变化时调用watch里对应的函数 10Vue.js 样式绑定 class 与 style 是 HTML 元素的属性，用于设置元素的样式，我们可以用 v-bind 来设置样式属性。Vue.js v-bind 在处理 class 和 style 时， 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数class 属性绑定1&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt; isActive为true时，调用class=”active”，为false时，不调用我们也可以在对象中传入更多属性用来动态切换多个 class 。123&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;&lt;/div&gt; 我们也可以直接绑定数据里的一个对象12345678910111213141516171819202122232425262728&lt;style&gt;.active &#123; width: 100px; height: 100px; background: green;&#125;.text-danger &#123; background: red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: &apos;#app&apos;, data: &#123; classObject: &#123; active: true, &apos;text-danger&apos;: true &#125; &#125;&#125;)&lt;/script&gt;&lt;/body&gt; 此外，我们也可以在这里绑定返回对象的计算属性123456789101112131415new Vue(&#123; el: &apos;#app&apos;, data: &#123; isActive: true, error: null &#125;, computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos;, &#125; &#125; &#125;&#125;) 数组语法我们可以把一个数组传给 v-bind:class123456789101112&lt;div id=&quot;app&quot;&gt; &lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: &apos;#app&apos;, data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos; &#125;&#125;)&lt;/script&gt; 我们还可以使用三元表达式来切换列表中的 class1&lt;div v-bind:class=&quot;[errorClass ,isActive ? activeClass : &apos;&apos;]&quot;&gt;&lt;/div&gt; Vue.js style(内联样式)我们可以在 v-bind:style 直接设置样式123&lt;div id=&quot;app&quot;&gt; &lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;菜鸟教程&lt;/div&gt;&lt;/div&gt; 也可以直接绑定到一个样式对象，让模板更清晰123&lt;div id=&quot;app&quot;&gt; &lt;div v-bind:style=&quot;styleObject&quot;&gt;菜鸟教程&lt;/div&gt;&lt;/div&gt; v-bind:style 可以使用数组将多个样式对象应用到一个元素上123&lt;div id=&quot;app&quot;&gt; &lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;菜鸟教程&lt;/div&gt;&lt;/div&gt; 注意：当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform ，Vue.js 会自动侦测并添加相应的前缀。 总结：v-bind提供很多种添加class或style的方法，我也不能一下一一全部记住，总而言之就是可以响应式的添加样式，改变个别样式可以使用style。]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 学习（一）]]></title>
    <url>%2F2018%2F04%2F19%2F2018_4_19_1%2F</url>
    <content type="text"><![CDATA[1Vue.js 安装 1.本地安装在 Vue.js 的官网上直接下载 vue.min.js 并用 script 标签引入。2.CDN 方法unpkg：https://unpkg.com/vue/dist/vue.js, 会保持和 npm 发布的最新的版本一致。cdnjs : https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js3.NPM 方法123456789# 查看版本$ npm -v2.3.0#升级 npmcnpm install npm -g# 最新稳定版$ cnpm install vue 在用 Vue.js 构建大型应用时推荐使用 NPM 安装 总结：npm方法不太明白什么意思，但是至少可以像JQuery一样可以本地导入或网页导入 2命令行工具 Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。123456789101112131415161718192021222324252627# 全局安装 vue-cli$ cnpm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 这里需要进行一些配置，默认回车即可This will install Vue 2.x version of the template.For Vue 1.x use: vue init webpack#1.0 my-project? Project name my-project? Project description A Vue.js project? Author runoob &lt;test@runoob.com&gt;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes vue-cli · Generated &quot;my-project&quot;. To get started: cd my-project npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpack 进入项目，安装并运行：123456$ cd my-project$ cnpm install$ cnpm run dev DONE Compiled successfully in 4388ms&gt; Listening at http://localhost:8080 成功执行以上命令后访问 http://localhost:8080/，可以看见搭建的网页 注意：Vue.js 不支持 IE8 及其以下 IE 版本。 总结：暂时用不到吧，而且也不知道有那些命令 3Vue.js 目录结构 目录/文件 说明 build 项目构建(webpack)相关代码 config 配置目录，包括端口号等。我们初学可以使用默认的。 node_modules npm 加载的项目依赖模块 src 这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：assets: 放置一些图片，如logo等。components: 目录里面放了一个组件文件，可以不用。App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。main.js: 项目的核心文件。 static 静态资源目录，如图片、字体等。 test 初始测试目录，可删除 .xxxx文件 这些是一些配置文件，包括语法配置，git配置等。 index.html 首页入口文件，你可以添加一些 meta 信息或统计代码啥的。 package.json 项目配置文件。 README.md 项目的说明文档，markdown 格式 总结：emmm…，不知道说什么好 4Vue.js 起步 每个 Vue 应用都需要通过实例化 Vue 来实现12345678910111213var vm = new Vue(&#123; el: &apos;#vue_det&apos;, data: &#123; data1:&quot;1&quot;, data2:&quot;2&quot;, data3:&quot;3&quot; &#125;, methods: &#123; function1: function() &#123; return data1; &#125; &#125; &#125;) Vue实例的el对应DOM的iddata用于定义属性methods用于定义的函数，可以通过 return 来返回函数值&#123;&#123; &#125;&#125;用于输出对象属性和函数返回值（用于DOM内）123&lt;div id=&quot;vue_det&quot;&gt; &lt;p&gt;&#123;&#123;data1&#125;&#125;&lt;/p&gt;&lt;/div&gt; 当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，html 视图将也会产生相应的变化。除了数据属性，Vue 实例还提供了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来。 总结：个人觉得就像是创建了一个object实例，然后提供了&#123;&#123; &#125;&#125;方法在DOM里直接显示出数据，并且可以时时改动，挺好理解的。 5Vue.js 模板语法 插值1.数据绑定最常见的形式就是使用&#123;&#123; &#125;&#125;的文本插值2.使用 v-html 指令用于输出 html 代码1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;message1&#125;&#125;&lt;/h1&gt; &lt;div v-html=&quot;message2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: &apos;#app&apos;, data: &#123; message1: &apos;文本插值&apos; message2: &apos;&lt;h1&gt;HTML插值&lt;/h1&gt;&apos; &#125;&#125;)&lt;/script&gt; 属性HTML 属性中的值应使用 v-bind 指令以下实例判断 class2 的值，如果为 true 使用 class1 类的样式，否则不使用该类：1&lt;div v-bind:class=&quot;&#123;&apos;class1&apos;: class2&#125;&quot;&gt; 表达式Vue.js 都提供了完全的 JavaScript 表达式支持。在&#123;&#123; &#125;&#125;里或v-bind:class=””里使用js表达式都没有问题，比如123456789101112&lt;div id=&quot;app&quot;&gt;&#123;&#123;5+5&#125;&#125;&lt;br&gt;&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;&lt;br&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: &apos;#app&apos;, data: &#123; ok: true, &#125;&#125;)&lt;/script&gt; 指令指令是带有 v- 前缀的特殊属性指令用于在表达式的值改变时，将某些行为应用到 DOM 上1&lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt; 这里， v-if 指令将根据表达式 seen 的值(true 或 false )来决定是否插入 p 元素 参数参数在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性1&lt;a v-bind:href=&quot;url&quot;&gt;超链接&lt;/a&gt; href就是参数，告知 v-bind 指令将该元素的 href 属性与表达式 url 的值绑定另一个例子是 v-on 指令，它用于监听 DOM 事件：1&lt;a v-on:click=&quot;function&quot;&gt; 修饰符修饰符是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()1&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; 用户输入在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定12&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;input v-model=&quot;message&quot;&gt; 这里input通过v-model改变了message的值，同时也反应到了p上 过滤器Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。由”管道符”（|）指示1&#123;&#123; message | function &#125;&#125; 过滤器函数接受表达式的值作为第一个参数。function为函数，message为参数传入function内过滤器可以串联：1&#123;&#123; message | filterA | filterB &#125;&#125; 过滤器是 JavaScript 函数，因此可以接受参数：1&#123;&#123; message | filterA(&apos;arg1&apos;, arg2) &#125;&#125; 这里，message 是第一个参数，字符串 ‘arg1’ 将传给过滤器作为第二个参数， arg2 表达式的值将被求值然后传给过滤器作为第三个参数。 缩写Vue.js 为两个最为常用的指令提供了特别的缩写v-bind和v-on12345678&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt; 总结：Vue.js模板语法还挺多的，我个人感觉更像是把js响应式的写进了DOM里，更加直观一些，语法谁然多，但是都不是很难。]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义网页右键菜单（补充）]]></title>
    <url>%2F2018%2F04%2F18%2F2018_4_18_2%20%2F</url>
    <content type="text"><![CDATA[鼠标事件 button值 备注 click 0 单击鼠标左键 click 1 单击鼠标中键 mousedown 0 按下鼠标左键 mousedown 1 按下鼠标中键 mousedown 2 按下鼠标右键]]></content>
      <tags>
        <tag>鼠标点击事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用CSS实现折叠面板]]></title>
    <url>%2F2018%2F04%2F18%2F2018_4_18_1%2F</url>
    <content type="text"><![CDATA[效果：使用input的radio单选框特性结合CSS中的伪元素实现bootstrap中折叠面板，要求样式一致。 要使用到的是 radio，label，伪类，兄弟相邻选择器 radio：单选框 label：文本框 伪类：:checked —选中时添加的类兄弟相邻选择器：li+li {…} 我的思路：1创建区域section2在section中建立3个radio，css设置radio的样式：dispaly:none3再创建3个label，绑定对应的radio4在label里写上标题，然后在里面创建div标签，再建立p标签，写入对应的内容5最后在css里给给div绑定对应的css3动画到这里为止差不多就成型了 我遇到的问题：1radio没有单选框效果产生的原因：没有给3个radio给定相同的name属性解决办法：123&lt;input type="radio" id="one" name="cascade" /&gt;&lt;input type="radio" id="two" name="cascade" /&gt;&lt;input type="radio" id="three" name="cascade" /&gt; 2绑定的动画没有动画的过度效果产生原因：高度再没有具体数值时，不会产生动画解决办法：给高度一个固定数值1height: 250px; 建议div高度和section宽度，不要使用百分比，以免出现显示不全或空白太多的情况 3绑定动画后，刷新页面会产生折叠动画产生的原因：我给div绑定了折叠动画，因为不绑定会再失去checked时直接消失，但是绑定了折叠动画会在开始时就先播放动画。解决办法：建议使用css3的过滤1transition: height 1s linear; 过滤只在对应属性改变时才会产生动画。 4折叠框没办法全部折叠产生的原因：radio选择后必须有一个选中解决办法：使用js改变radio只能有一个被选中的情况（还是用到了js…，我感觉还不如用js让多选框只能单选来的简单）1234567891011121314151617代码部分还不会，所以借鉴别人的 document.body.onmousedown = function (event) &#123; event = event || window.event; var target = event.target || event.srcElement; if (target.type === 'radio') &#123; target.previousValue = target.checked; &#125; &#125; document.body.onclick = function (event) &#123; event = event || window.event; var target = event.target || event.srcElement; if (target.type === 'radio') &#123; if (target.previousValue) &#123; target.checked = false; &#125; &#125; &#125; 但只对点击radio有效。。。 最后贴出我的代码： index.html （html文件）1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/mycss.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;input type="radio" id="one" name="cascade" /&gt; &lt;label for="one"&gt;Collapsible Group Item #1 &lt;div&gt;&lt;p&gt;Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson ad squid. 3 wolf moon officia aute, non cupidatat skateboard dolor brunch. Food truck quinoa nesciunt laborum eiusmod. Brunch 3 wolf moon tempor, sunt aliqua put a bird on it squid single- origin coffee nulla assumenda shoreditch et. Nihil anim keffiyeh helvetica, craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. Leggings occaecat craft beer farm-to-table, raw denim aesthetic synth nesciunt you probably haven't heard of them accusamus labore sustainable VHS. &lt;/p&gt;&lt;/div&gt; &lt;/label&gt; &lt;input type="radio" id="two" name="cascade" /&gt; &lt;label for="two"&gt;Collapsible Group Item #2 &lt;div&gt;&lt;p&gt;Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson ad squid. 3 wolf moon officia aute, non cupidatat skateboard dolor brunch. Food truck quinoa nesciunt laborum eiusmod. Brunch 3 wolf moon tempor, sunt aliqua put a bird on it squid single- origin coffee nulla assumenda shoreditch et. Nihil anim keffiyeh helvetica, craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. Leggings occaecat craft beer farm-to-table, raw denim aesthetic synth nesciunt you probably haven't heard of them accusamus labore sustainable VHS. &lt;/p&gt;&lt;/div&gt; &lt;/label&gt; &lt;input type="radio" id="three" name="cascade" /&gt; &lt;label for="three"&gt;Collapsible Group Item #3 &lt;div&gt;&lt;p&gt;Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson ad squid. 3 wolf moon officia aute, non cupidatat skateboard dolor brunch. Food truck quinoa nesciunt laborum eiusmod. Brunch 3 wolf moon tempor, sunt aliqua put a bird on it squid single- origin coffee nulla assumenda shoreditch et. Nihil anim keffiyeh helvetica, craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. Leggings occaecat craft beer farm-to-table, raw denim aesthetic synth nesciunt you probably haven't heard of them accusamus labore sustainable VHS. &lt;/p&gt;&lt;/div&gt; &lt;/label&gt; &lt;/section&gt; &lt;script src="js/myjs.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; mycss.css（css文件）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849*&#123; margin: 0; padding: 0; &#125; body,html&#123; width: 100%; height: 100%; &#125; /*折叠框局域*/ section&#123; width: 500px; margin: auto; margin-top: 20px; border: 1px solid #ddd; border-radius: 4px; &#125; /*设置单选框不可见*/ input[type="radio"] &#123; display: none; &#125; label&#123; display: block; border: 1px solid #ddd; border-radius: 4px; margin: 10px; padding: 10px; background-color: #f5f5f5; overflow: hidden; &#125; div&#123; font-size: 15px; overflow: hidden; height: 0; padding: 0; display: block; margin: -12px; margin-top: 10px; background-color: #fff; border: 1px solid #ddd; border-radius: 0px 0px 4px 4px; transition: height 1s linear; &#125; p&#123; margin: 10px; &#125; /*单选宽选中时改变高度*/ input[type="radio"]:checked+label div&#123; height: 250px; &#125; myjs.js（javascript文件）12345678910111213141516document.body.onmousedown = function (event) &#123; event = event || window.event; var target = event.target || event.srcElement; if (target.type === 'radio') &#123; target.previousValue = target.checked; &#125;&#125;document.body.onclick = function (event) &#123; event = event || window.event; var target = event.target || event.srcElement; if (target.type === 'radio') &#123; if (target.previousValue) &#123; target.checked = false; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义网页右键菜单]]></title>
    <url>%2F2018%2F04%2F17%2F2018_4_17_2%2F</url>
    <content type="text"><![CDATA[效果：在特定区域点击鼠标右键，弹出自定义菜单。 要使用到的是 contextmenu 事件 contextmenu效果：初始右键效果 我的思路：1创建区域div2js重新定义右键效果3重定义右键效果为创建一个ul里面是多个li，li里写入菜单文字4创建的ul需要定位在鼠标当前位置5然后创建完ul后给各个li绑定click事件到这里为止差不多就成型了 需要解决的问题：1得创建一个消除ul的方法不然会一直创建ul，那么什么时候应该消除ul，在区域中点击左键或中键，点击右键先的消除ul再重新创建ul，点击ul内部的li，先产生效果再消除ul2创建的ul消除后click事件消失应该在创建ul的时候就绑定事件，如果在ul消失后绑定事件会报错 我遇到的问题：1创建区域时，使用百分比的高度，没效果产生的原因：没有给body和html定义高度，区域的高度百分比继承于body，body继承于html解决办法：1234html,body&#123; width: 100%; height: 100%;&#125; 2给li绑定事件不生效产生的原因：我是通过给产生的li添加属性index值来判断是哪个菜单的，然后获取到li的index值来绑定对应的事件，但是通过 getAttribute() 方法获取的index值默认为字符串，然后使用 if(index == number) 时，判断不相同。解决办法：12let index_0 = li_0.getAttribute("index");index_0 = index_0 - 0; 使用 - 0，可以快速转变为数字类型（算是小及技巧吧！！！） 最后贴出我的代码： index.html （html文件）1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/mycss.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="area"&gt; &lt;p&gt;在区域中点击右键查看菜单&lt;/p&gt; &lt;/div&gt; &lt;script src="js/myjs.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; mycss.css（css文件）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657*&#123; margin: 0; padding: 0;&#125;html,body&#123; width: 100%; height: 100%;&#125;#area&#123; width: 50%; height: 50%; margin: auto; margin-top: 100px; background-color: #fff; border: 1px solid #000;&#125;ul&#123; overflow: hidden; position: absolute; list-style-type: none; /*border: 1px solid #000;*/ border-radius: 10px; box-shadow: 0px 0px 5px #000; background-color: #fff; width: 150px;&#125;li&#123; /*margin-left: 10px; margin-right: 10px;*/ padding-top: 5px; padding-bottom: 5px; padding-left: 10px; background-color: #fff; border-bottom: 1px solid #eee; /*cursor: pointer;*/&#125;li&#123; -moz-user-select:none;/*火狐*/ -webkit-user-select:none;/*webkit浏览器*/ -ms-user-select:none;/*IE10*/ -khtml-user-select:none;/*早期浏览器*/ user-select:none;&#125;/*文字不可选中*/.last&#123; border: none;&#125;.box&#123; border: 1px solid #eee; width: 100px; height: 100px; position: absolute; top: 0; left: 0;&#125;.on&#123; background-color: #999;&#125; myjs.js（javascript文件）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163let area = document.getElementById("area");//点击区域let client_x;//鼠标当前的x坐标let client_y;//鼠标当前的y坐标let index = 0;//判断是否有菜单，有为1，无为0let index_1 = 0;//判断菜单1是否已点击，点击为1.未点击为0let index_2 = 0;//判断菜单2是否已点击，点击为1.未点击为0let index_3 = 0;//判断菜单3是否已点击，点击为1.未点击为0//给区域绑定contextmenu事件，重新定义右键效果area.addEventListener("contextmenu",function(e)&#123; if(window.event)&#123; e = window.event; &#125; e.preventDefault(); //阻止原有的菜单 e.returnValue = false; //在IE中阻止原有的菜单 e.stopPropagation(); //判断是否已经有菜单 if(index == 0)&#123; determine(); addlist(); &#125; else&#123; cleanlist(); determine(); addlist(); &#125;&#125;,false);//给区域绑定左键和中键效果，消除菜单area.addEventListener("mousedown",function(e)&#123; if(e.button == 1||e.button == 0)&#123; cleanlist(); &#125;&#125;,false);//获取鼠标当前的xy坐标function determine(e)&#123; e = event || window.event; client_x = e.clientX; client_y = e.clientY;&#125;//产生菜单function addlist()&#123; let ul_0 = document.createElement("ul"); ul_0.setAttribute("id","meau"); for(let i = 0; i &lt; 3; i++)&#123; (function(i)&#123; let li_0 = document.createElement("li"); li_0.setAttribute("index",i); if(i == 2)&#123; li_0.setAttribute("class","last"); &#125; switch(i)&#123; case 0: if(index_1 == 1)&#123; li_0.setAttribute("class","on"); &#125; li_0.innerHTML = "背景变红"; break; case 1: if(index_2 == 1)&#123; li_0.setAttribute("class","on"); &#125; li_0.innerHTML = "字体变大" break; case 2: if(index_3 == 1)&#123; li_0.className += " on"; &#125; li_0.innerHTML = "边框变粗" break; &#125; ul_0.appendChild(li_0); &#125;)(i); &#125; ul_0.style.left = client_x+"px"; ul_0.style.top = client_y+"px"; document.body.appendChild(ul_0); addfunction(ul_0); index = 1;&#125;//清除菜单function cleanlist()&#123; if(index == 0)&#123; return; &#125; let box = document.getElementById("meau"); document.body.removeChild(box); index = 0;&#125;//给产生的菜单添加事件function addfunction(ul_0)&#123; for(let i = 0; i &lt; 3; i++)&#123; (function(i)&#123; let li_0 = ul_0.getElementsByTagName("li")[i]; let index_0 = li_0.getAttribute("index"); index_0 = index_0 - 0; switch(index_0)&#123; case 0: addfunction_0(li_0); break; case 1: addfunction_1(li_0); break; case 2: addfunction_2(li_0); break; &#125; &#125;)(i); &#125;&#125;//给菜单1绑定事件function addfunction_0(li_0)&#123; li_0.addEventListener("click",function(e)&#123; e.stopPropagation(); if(index_1 == 0)&#123; area.style.backgroundColor = "red"; cleanlist(); index_1 = 1; &#125; else&#123; area.style.backgroundColor = "#fff"; cleanlist(); index_1 = 0; &#125; &#125;,false);&#125;//给菜单2绑定事件function addfunction_1(li_0)&#123; li_0.addEventListener("click",function()&#123; if(index_2 == 0)&#123; area.style.fontSize = "32px"; cleanlist(); index_2 = 1; &#125; else&#123; area.style.fontSize = "16px"; cleanlist(); index_2 = 0; &#125; &#125;,false);&#125;//给菜单3绑定事件function addfunction_2(li_0)&#123; li_0.addEventListener("click",function()&#123; if(index_3 == 0)&#123; area.style.border = "5px solid #000"; cleanlist(); index_3 = 1; &#125; else&#123; area.style.border = "1px solid #000"; cleanlist(); index_3 = 0; &#125; &#125;,false);&#125;]]></content>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2018%2F04%2F17%2F2018_4_17_1%2F</url>
    <content type="text"><![CDATA[emmm…,这是我的第一篇博客，不知道该写什么，就记录一下自己怎么跟着大佬的步伐使用github和hexo搭建个人博客好了。 要使用到的是github,node.js,hexo 我的博客搭建在 GitHub Pages上 GitHub Pages本用于介绍托管在GitHub的项目， 不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。 1安装git node.js直接next选择安装目录即可 2配置node.js环境变量在环境变量里的path下添加node.js的安装目录即可 3安装hexo打开cmd,进入node.js安装目录下,利用 npm 命令即可安装1npm install -g hexo 以上是安装必要的组件,然后可以开始搭建个人博客 4搭建个人博客依旧在cmd的node.js目录下输入 1mkdir blog &amp;&amp; cd blog bolg是你的博客目录,可以自行更改,记得备份好文件,以免丢失1hexo init 安装依赖包1npm install 至此,博客搭建成功! 当然,仅仅是本地的了。此时执行1hexo g 即可生成静态页面，然后执行1hexo s 访问 http://localhost:4000 即可看到你的博客。 5部署博客到github注册github账号,并登录 创建仓库 注：Github Pages的Repository名字是特定的，比如我Github账号是FrattiNor，那么我Github Pages Repository的名字就是FrattiNor.github.io。 设置github pages 选择主题并发布即可 然后复制你github page的https链接进入的bolg文件夹下修改_config.yml文件修改底部的repository为刚刚复制的链接如下 deploy:type: gitrepository: https://github.com/FrattiNor/FrattiNor.github.io.gitbranch: master 最后回到cmd执行12npm install hexo-deployer-git --save （这命令是为了解决hexo新版本的部署问题） 12hexo g （这是重新生成blog） 12hexo d（这是将本地blog部署到github的仓库） 试试在浏览器的地址栏输入：“https://你的用户名.github.io/” 这样个人博客就搭建完成了，然后就可以修改主题和发布博文了 主题在这里 https://github.com/hexojs/hexo/wiki/Themes博文使用makedown编写]]></content>
      <tags>
        <tag>第一</tag>
        <tag>如何搭建个人博客</tag>
      </tags>
  </entry>
</search>
